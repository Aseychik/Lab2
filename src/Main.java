import java.io.IOException;
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    // Объявляем объект класса Scanner для ввода данных
    public static Scanner in = new Scanner(System.in);
    // Объявляем объект класса PrintStream для вывода данных
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // Ввод размеров массива
        int n = in.nextInt(), m = in.nextInt();
        // Если n или m не подходят для размеров массива их нужно ввести снова
        while (n <= 0 || m <= 0){
            out.println("n и m должны быть натуральными числами\nВведите n и m заново: ");
            n = in.nextInt();
            m = in.nextInt();
        }

        // Создание массива целых чисел
        int[][] arr = new int[n][m];
        // Создание массива минимальной суммы элементов строки и её номера
        long[] minst = new long[]{0, 0};
        // Создание массива сумм строк
        long[] sumarr = new long[n];
        // Создание переменной максимальной суммы элементов строки
        long maxsum = 0;
        // Создание переменной для вычисления среднего арифметического всех сумм строк
        double average = 0;

        // Задание элементов массива
        for (int i = 0; i < n; i++) {
            // Переменная для вычисления суммы строки
            long temp = 0;
            for (int j = 0; j < m; j++) {
                // Добавления элемента в массив
                arr[i][j] = in.nextInt();
                // Прибавление значения этого элемента к счётчику суммы строки
                temp += arr[i][j];
            }
            // Прибавление суммы строки к переменной для вычисления среднего арифметического
            average += temp;
            // Добавление в массив сумм суммы элементов новой строчки
            sumarr[i] = temp;
            // Если строчка первая, то задание изначальных значений для минимальной и
            // максимальной суммы элементов строки
            if (i == 0) {
                minst = new long[]{temp, 0};
                maxsum = temp;
            }
            // Иначе сравнение суммы элементов данной строки с прошлой минимальной и максимальной суммой
            else {
                if (temp < minst[0])
                    minst = new long[]{temp, i};
                if (temp > maxsum)
                    maxsum = temp;
            }
        }

        // Создание массива критериев для сортировки для каждого столбца
        int[][] sortarr = new int[m][4];
        for (int j = 0; j < m; j++) {
            // 0 - максимальный элемент столбца
            sortarr[j][0] = arr[0][j];
            // 1 - минимальный элемент столбца
            sortarr[j][1] = arr[0][j];
            // 2 - сумма квадратов всех элементов столбца
            sortarr[j][2] = arr[0][j] * arr[0][j];
            // 3 - номер столбца в изначальном массиве
            sortarr[j][3] = j;
            // вычисление максимального, минимального элемента столбца и суммы квадратов всех элементов столбца
            for (int i = 1; i < n; i++) {
                // Проход по элементам столбца
                int temp = arr[i][j];
                // Вычисление максимального
                if (temp > sortarr[j][0])
                    sortarr[j][0] = temp;
                // Вычисление минимального
                if (temp < sortarr[j][1])
                    sortarr[j][1] = temp;
                // Вычисление суммы квадратов всех элементов столбца
                sortarr[j][2] += Math.abs(temp);
            }
        }

        // Сортировка пузырьком массива услов
        for (int c = 1; c < m; c++) {
            // Добавление проверки, отсортирован ли уже массив
            boolean sorted = true;
            for (int j = 1; j <= m - c; j++) {
                // Нужно ли менять на данном шаге элементы массива местами
                boolean chan = false;
                // Если максимальные элементы равны
                if (sortarr[j - 1][0] == sortarr[j][0]) {
                    //Если минимальные элементы равны сравнивать по сумме квадратов элементов столбца
                    if (sortarr[j - 1][1] == sortarr[j][1])
                        chan = sortarr[j - 1][2] > sortarr[j][2];
                    else // Нужно менять элементы местами, если их минимальные элементы стоят по возрастанию
                        chan = sortarr[j - 1][1] < sortarr[j][1];
                } else // Нужно менять элементы местами, если их максимальные элементы стоят по возрастанию
                    chan = sortarr[j - 1][0] < sortarr[j][0];
                // Поменять местами два элемента массива если это необходимо
                if (chan) {
                    int[] temp = sortarr[j-1];
                    sortarr[j-1] = sortarr[j];
                    sortarr[j] = temp;
                    // Это означает, что массив ещё может быть не отсортированным
                    sorted = false;
                }
            }
            // Если массив отсортирован можно остановить сортировку
            if (sorted) break;
        }

        // Создание отсортированного изначального массива
        int[][] nwarr = new int[n][m];
        for (int j = 0; j < m; j++) {
            for (int i = 0; i < n; i++) {
                // Проходимся по всем элементам массива
                // и ставим на их места элементы из соответствующих уже отсортированных столбцов
                nwarr[i][j] = arr[i][sortarr[j][3]];
            }
        }

        // Вывод минимальной суммы всех элементов строки и её номер
        out.println("Минимальная сумма элементов строки: " + minst[0] + "\nНомер этой строки: " + (minst[1]+1));
        // Переменная сдвига, используемая для вывода массива в виде треугольника
        int shift = 1;
        for (int i = 0; i < n*m; i++){
            // Если i является квадратом переменной shift - перенос строки и прибавление 1 к переменной shift
            if (i == shift*shift){
                out.println();
                shift++;
            }
            // Вывод элемента массива отсортированного списка
            out.print(nwarr[i / m][i%m] + " ");
        }
        // Вычисление среднего арифметического
        average = average / n;
        // Вывод разницы между максимальной и минимальной суммы элементов строк и среднего арифметического сумм строк
        out.println("\nРазница между максимальной и минимальной суммой строк: " + (maxsum - minst[0]));
        out.println("Среднее арифметическое сумм строк: " + average);
        // Переменная для стандартного отклонения сумм строк
        double deviat = 0;
        for (int i = 0; i < n; i++){
            // Вычисление стандартного отклонения сумм строк
            deviat += (sumarr[i] - average)*(sumarr[i] - average);
        }
        // Вывод стандартного отклонения сумм строк
        out.print("Стандартное отклонение сумм строк: " + Math.sqrt(deviat/(n-1)));
    }
}
